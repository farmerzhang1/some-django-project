{% load static %}

<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>upload</title>
  <link rel="stylesheet" href="{% static 'css/style.css' %}" media="screen">
  <link rel="stylesheet" href="{% static 'css/upload.css' %}">
  <script type="text/javascript" src="{% static 'js/jquery-3.6.0.min.js' %}"></script>
  <!-- Create a simple CodeMirror instance -->
  <link rel="stylesheet" href="{% static 'css/codemirror.css' %}">
  <script src="{% static 'js/codemirror.js' %}"></script>
  <script src="{% static 'js/simple.js' %}"></script>
  <!-- <script src="{% static 'js/javascript.js' %}"></script> -->
</head>

<body>
  <div id="wrapper">
    <nav>
      <ul>
        <li>首页</li>
        <!-- <li>1</li>
        <li>2</li>
        <li>3</li> -->
      </ul>
    </nav>

    <div class="sub">
      <h1>协议形式化验证</h1>
      <!-- <h2>Upload your file and give it a try!</h2> -->

      <div class="upload-container">
        <form class="form" method="POST" action="" enctype="multipart/form-data">{% csrf_token %}
          <div class="file-upload-wrapper" data-text="请输入协议名称">
            {{ form.file }}
            <progress id="progressBar" value="0" max="100" style="width:300px;"></progress>
          </div>
          {{ form.text }}
          <input type="submit" class="upload-btn" value="协议上传">
          <input type="submit" class="upload-btn" value="协议验证">
        </form>
      </div>
      <script>
        /* Example definition of a simple mode that understands a subset of
        * JavaScript:
        */
        // alert('pre define simple mode')
        CodeMirror.defineSimpleMode("spthy", {
          // The start state contains the rules that are initially used
          start: [
            // The regex matches the token, the token property contains the type
            { regex: /"(?:[^\\]|\\.)*?(?:"|$)/, token: "string" },
            // You can match multiple tokens at once. Note that the captured
            // groups must span the whole string in this case
            {
              regex: /\b(axiom|restriction|lemma|sources|use_induction|reuse|hide_lemma|left|right|builtins|protocol|property|subsection|section|text)\b/,
              token: ["keyword", null, "variable-2"]
            },
            // {
            //   regex: /\b(xor|aenc|adec|senc|sdec|sign|verify|Eq|eq|hashing|signing|revealing-signing|diffie-hellman|symmetric-encryption|asymmetric-encryption|multiset|bilinear-pairing|h|H|sk|pk|Fr|In|Out|IN|OUT)\b/,
            //   token: "variable.language"
            // },
            // Rules are matched in the order in which they appear, so there is
            // no ambiguity between this one and the one above
            {
              regex: /\b(equations|functions|builtins|protocol|property|theory|begin|end|subsection|section|text|rule|pb|lts|exists-trace|all-traces|enable|assertions|modulo|default_rules|anb-proto|in|let|Fresh|fresh|Public|public)\b/,
              token: "keyword.control"
            },
            // { regex: /true|false|null|undefined/, token: "atom" },
            {
              regex: /0x[a-f\d]+|[-+]?(?:\.\d+|\d+\.?\d*)(?:e[-+]?\d+)?/i,
              token: "number"
            },
            { regex: /\b(in|let|begin|end)\b/, token: "constant.language" },
            { regex: /\/\/.*/, token: "comment" },
            // { regex: /\/(?:[^\\]|\\.)*?\//, token: "variable-3" },
            // A next property will cause the mode to move to a different state
            { regex: /\/\*/, token: "comment", next: "comment" },
            { regex: /[-+\/*=<>!]+/, token: "operator" },
            // indent and dedent properties guide autoindentation
            { regex: /[\{\[\(]/, indent: true },
            { regex: /[\}\]\)]/, dedent: true },
            { regex: /[a-z$][\w$]*/, token: "variable" },
            // You can embed other modes with the mode property. This rule
            // causes all code between << and >> to be highlighted with the XML
            // mode.
            { regex: /<</, token: "meta", mode: { spec: "xml", end: />>/ } }
          ],
          // The multi-line comment state.
          comment: [
            { regex: /.*?\*\//, token: "comment", next: "start" },
            { regex: /.*/, token: "comment" }
          ],
          // The meta property contains global information about the mode. It
          // can contain properties like lineComment, which are supported by
          // all modes, and also directives like dontIndentStates, which are
          // specific to simple modes.
          meta: {
            dontIndentStates: ["comment"],
            lineComment: "//"
          }
        });
      </script>
      <script>
        var editor = CodeMirror.fromTextArea(document.getElementById('js-textarea'), {
          lineNumbers: true,
          mode: "spthy",
        });
        //Hide
        // alert('pre hide')
        $(editor.getWrapperElement()).hide();
        // alert('after hide')
        //Show
        $(".file-upload-field").change(function () {
          var reader = new FileReader();
          reader.onload = function (e) {
            $("#js-textarea").val(e.target.result);
          };
          reader.readAsText($(".file-upload-field")[0].files[0], "UTF-8");
          reader.onload = function () { editor.setValue(reader.result); }
          editor.setSize("100%", "380px")
          $(editor.getWrapperElement()).show();
          // alert('after show')
        });

      </script>
      <script type="text/javascript" src="{% static 'js/upload.js' %}"></script>
    </div>
    <footer>
      <p>中国科学技术大学网络安全实验室</p>
    </footer>
  </div>
</body>

</html>
